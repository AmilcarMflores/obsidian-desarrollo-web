Las funciones son bloques que agrupan sentencias, declaraciones de variables, bucles y otras instrucciones.
### Invocar funciones
Las funciones tiene paréntesis al final:
```javascript
nameOfTheFunction();
functionThatTakesInput("the input", 5, true);
```
### Escribir funciones
Para crear funciones usamos la palabra `function`, por ejemplo crearemos una función que pida nombre y luego salude:
```javascript
function sayHello() {
    let you = prompt("What is your name? ");
    console.log("Hello", you + "!");
}

sayHello();
```
### Nombrar funciones
- Para nombrar funciones usa `camelCase`.
- Asegurarse de que el nombre describe lo que hace la función.
- Usar un verbo para describir la función.
## Parámetros y argumentos
```javascript
function tester(para1, para2) {
    return para1 + " " + para2;
}
const arg1 = "argument 1";
const arg2 = "argument 2";
tester(arg1, arg2);
```
## Parámetros predeterminados
```javascript
function addTwoNumbers(x = 2, y = 3) {
    console.log(x + y);
}

addTwoNumbers(); // 5
addTwoNumbers(5, 7); // 12
addTwoNumbers(10); // 13
```
## Funciones y operadores especiales
Existen algunas formas especiales de escribir funciones, así como operadores especiales que resultarán útiles.
### Funciones de flecha
- Son una forma de escribir funciones: `(param1, param2) => body-of-the-function;`.
- Sin parámetros: `() => body-of-the-function;`
- Solo un parámetro: `param => body-of-the-function;`

Para una función multilínea con dos parámetros:
```bash
(param1, param2) => {
	// line 1;
	// any number of lines;
}
```

**Las funciones de flecha son útiles cuando se desea escribir una implementación al instante.** Por ejemplo, dentro de otra función como argumento.

Ejemplos para entender:
```javascript
let doingArrowStuff = x => console.log(x);
doingArrowStuff("Great!"); // Great!

let addTwoNumbers = (x, y) => console.log(x + y);
addTwoNumbers(5, 3); // 8

let sayHi = () => console.log("Hello!");
sayHi(); // Hello!

const arr = ["squirre1", "alpaca", "buddy"];
arr.forEach(e => console.log(e));
// squirre1
// alpaca
// buddy
```
### Operador de propagación
```javascript
let spread = ["so", "much", "fun"];
let message = ["JavaScript", ...spread, "and", "very", "powerful"];
console.log(message); // [JavaScript, so, much, fun, and, very, powerful]

function addTwoNumbers(x, y) {
    console.log(x + y);
}

let arr = [5, 9];
addTwoNumbers(...arr); // 14

function addFourNumbers(x, y, z, a) {
    console.log(x + y + z + a);
}
let arr1 = [5, 9];
let arr2 = [6, 7];
addFourNumbers(...arr1, ...arr2); // 27
```
### Parámetro de descanso
Si usamos este parámetro, podemos enviar cualquier cantidad de argumentos y convertirlos en un array de parámetros:
```javascript
function someFunction(param1, ...param2) {
    console.log(param1, param2);
}
someFunction("hi", "there!", "How are you?"); // hi [ 'there!', 'How are you?' ]
```
## Retornando valores de la función
Las funciones pueden devolver un resultado cuando especificamos un valor de retorno:
```javascript
function addTwoNumbers(a, b) {
    return a + b;
}

let result = addTwoNumbers(5, 10);
console.log("The result is: " + result); // 15
```
## Retornando en funciones de flecha
Podemos retornar si usar la palabra `return`:
```javascript
let addTwoNumbers1 = (x, y) => x + y;
let result = addTwoNumbers1(5, 10);
console.log(result); // 15

let addTwoNumbers2 = (x, y) => {
    console.log("Adding...");
    return x + y;
}
let result2 = addTwoNumbers2(12, 15);
console.log(result2); // 27
```
## ## Expresión función invocada inmediatamente (IIEF)
Una IIFE (Immediately Invoked Function Expression) es una función que se define y se ejecuta de inmediato. Normalmente es anónima (sin nombre) y se utiliza para crear un ámbito local aislado o para inicializar código sin contaminar el ámbito global.

- Se ejecuta en el momento en que se define.
- Crea un scope propio, evitando conflictos con variables globales.
- Útil para inicializaciones y patrones de diseño (módulos, closures, encapsulamiento).

Función tradicional anónima:
```javascript
(function() {
    console.log("IIEF!");
})();
```
(); ejecuta la función si nombre.

Flecha:
```javascript
(() => {
    console.log("run right away");
})();
```

- Los paréntesis alrededor de la expresión de función le indican al intérprete que lo que sigue es una expresión, no una declaración de función. Los paréntesis finales () invocan la función.
- También puedes pasar argumentos o devolver valores:
## Funciones recursivas
```javascript
function getRecursive(nr) {
    console.log(nr);
    if( nr > 0) {
        getRecursive(--nr);
    }
}

getRecursive(3);
```
## Funciones anónimas
Podemos crear funciones sin nombre y se denominan funciones anónimas.
```javascript
let functionVariable = function() {
    console.log("Not so secret though");
};

functionVariable();
```
## Function callbacks
```javascript
function doFlexibleStuff(executeStuff) {
    executeStuff();
    console.log("Inside doFlexibleStuffFunction");
}

let functionVariable = function() {
    console.log("Not so secret though");
};

doFlexibleStuff(functionVariable);

/*
Not so secret though
Inside doFlexibleStuffFunction
*/
```

