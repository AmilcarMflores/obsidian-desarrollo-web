## Expresiones regulares
- También conocidas como `regex`, son simplemente formas de describir patrones de texto.
- Las regex son muy útiles, por ejemplo, cuando necesitas buscar errores en un archivo grande o recuperar el agente de navegación que está usando un usuario. También se puede usar para la validación de formularios.
- Las regex no solo son útiles para encontrar cadenas, sino también para reemplazarlas, pero si regex es tan completa, ¿hay alguna desventaja?

Sí, las regex pueden parecer como si el gato de tu vecino hubiera caminado sobre tu teclado y escrito algunos caracteres al azar. Por ejemplo, esta regex verifica un email válido: ```/([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)/g```. Ahora no lo entendemos, pero en este capítulo podremos descifrar estos patrones.

Primero, el patron `regex` se especifica entre dos barras diagonales: `/JavaScript/`

Podemos usar la función incorporada `match()` de JavaScript, esta función devuelve la coincidencia regex en forma de la subcadena que coincidió, la posición inicial de esta cadena y la cadena de entrada.

En realidad, hay otras funciones integradas que usan regex, pero las veremos más adelante. `match()` es simplemente una función conveniente para demostrar cómo funciona regex:
```javascript
let text = "I love JavaScript!";
console.log(text.match(/javascript/));
```
Esto registra `null` porque, por defecto, es sensible a mayúsculas y minúsculas y por lo tanto, no hay coincidencia. Si hubiéramos buscado `/ava/` o simplemente `/a/`, habría coincidido.

Si quieres que sea insensible a mayúsculas y minúsculas, puedes especificarlo usando una `i` después de la barra:
```javascript
console.log(text.match(/javascript/i));
```

### Especificar múltiples opciones para palabras
Para especificar un cierto rango de opciones, podemos usar esta sintaxis:
```javascript
let text = "I love React and JavaScript!";
console.log(text.match(/javascript|nodejs|react/i));
```
Aquí, la expresión coincide con "javascript", "nodejs" o "react". Solo buscamos la primera coincidencia y luego paramos. Así que esto no va a encontrar dos o más coincidencias ahora mismo; mostrará lo mismo que antes.

Si queremos encontrar todas las coincidencias, podríamos especificar el modificador global `g`:
```javascript
let text = "I love React and JavaScript";
console.log(text.match(/javascript|nodejs|react/gi));
```

### Opciones de caracteres
Digamos que queremos buscar una cadena de un solo carácter que sea igual a `a`, `b` o `c`:
```javascript
let text = "d";
console.log(text.match(/[abc]/));
```
Nos devolverá `null` porque `d` no es `a`, `b`, o `c` 

Podemos incluir `d`:
```javascript
console.log(text.match(/[abcd]/));
```

Dado que este es un rango de caracteres, podemos escribirlo más corto:
```javascript
let text = "d";
console.log(text.match(/[a-d]/));
```

Y si quisiéramos cualquier letra, minúscula o mayúscula, escribimos:
```javascript
let let = "t";
console.log(text.match(/[a-zA-Z]/));
```

Si quisiéramos incluir números:
```javascript
console.log(text.match(/[a-zA-Z0-9]/));
```

También, el punto (`.`) funciona como un carácter comodín especial en regex que puede coincidir con cualquier carácter:
```javascript
let text = "Just some text.";
console.log(text.match(/./g));
```

Si quieres que un carácter especial (uno que se usa en regex para especificar un patrón) tenga un significado normal, o que un carácter normal tenga un significado especial, puedes escaparlo usando la barra invertida (`\`):
```javascript
let text = "Just some text.";
console.log(text.match(/\./g));
```
Escapamos el punto agregando una barra invertida precedente. Por lo tanto, no funciona como un comodín y buscará una coincidencia literal.

Hay algunos caracteres normales que obtienen un significado especial al agregar una barra invertida antes:
```javascript
let text = "I'm 29 years old.";
console.log(text.match(/\d/g)); // \d coincide con cualquier dígito
```
Si escapamos la "d", `\d`, coincide con cualquier dígito. Estamos haciendo una búsqueda global, por lo que especificará cualquier código:
```javascript
[ '2', '9' ]
```

También podemos escapar la "s", `\s`, que coincide con todos los caracteres de espacio en blanco:
```javascript
let text = "Coding is a lot of fun!";
console.log(text.match(/\s/g));
```
Solo devolverá algunos espacios, pero las tabulaciones y otros tipos de espacios en blanco también están incluidos.

Uno muy útil es `\b`, que coincide con el texto solo cuando está al principio de una palabra:
```javascript
let text = "In the end or at the beginning?";
console.log(text.match(/\bin/gi));
```

Esto es lo que terminará registrando:
```javascript
[ 'In' ]
```

El método `match()` pertenece al objeto String, por lo que lo implementas en variables de cadena. Por ejemplo, si intentas:
```javascript
let nr = 357;
console.log(nr.match(/3/g));
```
Deberías recibir un TypeError que dice que `nr.match()` no es una función. Para usar `match()`, primero convierte el número a string: `nr.toString().match(/3/g)`.

### Grupos
Hay muchas razones para agrupar tu regex. Cada vez que quieras hacer coincidir un grupo de caracteres, puedes rodearlos con paréntesis:
```javascript
let text = "I love JavaScript!";
console.log(text.match(/(love|dislike)\s(javascript|spiders)/gi));
```
Aquí va a buscar "love" o "dislike", seguido de un carácter de espacio en blanco, seguido de "javascript" o "spiders", y lo hará para todas las ocurrencias ignorando si están en mayúsculas o minúsculas. 

Digamos que podemos coincidir con aproximadamente cuatro combinaciones aquí. Dos de ellas parecen tener más sentidos:
- Love spiders
- Dislike spiders
- Love JavaScript
- Dislike JavaScript

Los grupos son muy poderosos cuando sabemos cómo repetirlos. Veamos cómo hacerlo. Tenemos varias opciones para esto. Por ejemplo, si queremos coincidir con cuatro caracteres alfanuméricos en secuencia:
```javascript
let text = "I love JavaScript!";
console.log(text.match(/[a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9]/g));
```
Esta es una forma terrible de repetir un bloque, existe mejores opciones.

Si solo queremos que esté presente 0 o 1 vez, podemos usar el signo de interrogación. Esto es para caracteres opcionales:
```javascript
let text = "You are doing great!";
console.log(text.match(/n?g/gi));
```
Esto busca un carácter 'g' que puede o no estar precedido por una 'n'. 

Si quieres algo al menos una vez, pero opcionalmente más veces, puedes usar el signo más `+`
```javascript
let text = "123123123";
console.log(text.match(/(123)+/)); // [ '123123123', '123', index: 0, input: '123123123', groups: undefined ]
```
Esto va a coincidir con el gurpo "123" una o más veces. Y como esta cadena está presente, encontrará una coincidencia.

También hay situaciones en las que quieres que una determinada parte de la regex coincida cualquier número de veces, lo que se puede indicar con el asterisco `*`:

`/(123)*a/

Coincidirá con cualquier `a` precedida por `123` cualquier número de veces. Por lo tanto, coincidirá con lo siguiente, por ejemplo:
- 123123123a
- 123a
- a

Lo último a tener en cuenta sobre la repetición es que también podemos ser más específicos. Hacemos esto usando sintaxis `{min, max}`:
```javascript
let text = "abcabcabc";
console.log(text.match(/(abc){1,2}/));
```

Esto registrará:
```javascript
[ 'abcabc', 'abc', index: 0, input: 'abcabcabc', groups: undefined ]
```

Hemos estado usando grupos, pero `groups` sigue siendo `undefined` en la salida. Para especificar grupos, tendremos que nombrarlos. Veremos cómo hacer grupos con nombre (sintáxis `?<name>`):
```javascript
let text = "I love JavaScript!";
console.log(text.match(/(?<language>javascript)/i));
```

Esto producirá:
```javascript
[
  'JavaScript',
  'JavaScript',
  index: 7,
  input: 'I love JavaScript!',
  groups: [Object: null prototype] { language: 'JavaScript' }
]
```

## Funciones y el objeto `arguments`
JavaScript maneja los argumentos en las funciones agregándolos a un objeto personalizado llamado `arguments`. Este objeto funciona mucho como un array, y podemos usarlo en lugar de usar el nombre del parámetro.

Considera el siguiente código:
```javascript
function test(a, b, c) {
    console.log("first:", a, arguments[0]);
    console.log("second:", b, arguments[1]);
    console.log("third:", c, arguments[2]);
}

test("fun", "js", "secrets");
```

Esto produce:
```javascript
first: fun fun
second: js js
third: secrets secrets
```

Cuando actualizas uno de los parámetros, el argumento cambia en consecuencia. Y viceversa:
```javascript
function test(a, b, c) {
    a = "nice";
    arguments[1] = "JavaScript";
    console.log("first:", a, arguments[0]);
    console.log("second:", b, arguments[1]);
    console.log("third:", c, arguments[2]);
}

test("fun", "js", "secrets");
```

Esto va a cambiar tanto `arguments[0]` como `b`,  ya que están relacionados con `a` y `arguments[1]`, respectivamente, como puedes ver:
```javascript
first: nice nice
second: JavaScript JavaScript
third: secrets secrets
```

Si la función se llama con más argumentos de los declarados en la firma de la función, esta es la forma de acceder a ellos. Sin embargo, la forma moderna es usar el parámetro rest (`...param`) en lugar del objeto `arguments`.

## Hoisting en JavaScript
El hoisting es el principio de mover las declaraciones de variables a la parte superior del alcance en el que están definidas.

Esto te permite hacer cosas que no puedes hacer en muchos otros idiomas, y por una buena razón, por cierto, esto debería verse normal:
```javascript
var x;
x = 5;
console.log(x); // 5
```

Pero gracias el hoisting, esto también lo hace:
```javascript
x = 5;
console.log(x); // 5
var x;
```
Si lo haces con `let` te da error. Es por esta razón que es mejor usar `let`, porque claramente, este comportamiento es muy difícil de leer, impredecible.

La razón por la que esto sucede es que el intérprete de JavaScript mueve todas las declaraciones `var` a la parte superior del archivo antes de procesarlo.

## Usando el modo estricto
Podemos cambiar el comportamiento comprensivo e indulgente de JavaScript hasta cierto punto usando el modo estricto. Puedes activar el modo estricto con el siguiente comando en tu código. Este debe ser el primer comando de tu código:
```javascript
"use strict";
```

Aquí hay algo que funciona cuando no usamos el modo estricto:
```javascript
function sayHi() {
    greeting = "Hello!";
    console.log(greeting);
}

sayHi(); // Registra "Hello!"
```

Olvidamos declarar `greeting`, por lo que JavaScript lo hizo por nosotros agregando una variable `greeting` al nivel superior y registrará "Hello!". Sin embargo, si habilitamos el modo estricto, esto dará un error:
```javascript
"use strict";

function sayHi() {
    greeting = "Hello!"; // ReferenceError: greeting is not defined
    console.log(greeting);
}

sayHi();
```

Usar el modo estricto es una excelente manera de acostumbrarse a usar JavaScript en el entorno de frameworks o incluso para escribir TypeScript más tarde. Normalmente se considera una buena práctica en la actualidad, por lo que te recomendamos que lo uses en tu propio código cuando tengas la oportunidad. Sin embargo, a menudo no es una opción (fácil) cuando se trabaja con código antiguo existente.

## Manejo de errores
Si esperamos que una determinada pieza de código arroje un error, podemos rodear este código con un bloque `catch`. El error que pueda arrojar será capturado en este bloque.

Aquí hay un ejemplo de una pieza de código que arroja un error y está rodeada por un bloque `try` y `catch`. Supongamos que la función `somethingVeryDangerous()` podría arrojar errores:
```javascript
try {
    somethingVeryDangerous();
} catch (e) {
    if (e instanceof TypeError) {
        // manejar excepciones TypeError
    } else if (e instanceof RangeError) {
        // manejar excepciones RangeError
    } else if (e instanceof EvalError) {
        // manejar excepciones EvalError
    } else {
        // manejar todas las demás excepciones
        throw e; // relanzar el error
    }
}
```

Si arroja un error, terminará en el bloque `catch`. Dado que `Error` podría significar muchos errores diferentes, vamos a verificar el error exacto con el que estamos lidiando y escribir un manejo específico de este error. Verificamos la clase de error exacta con el operador `instanceof`. Después del manejo del error, el resto del código continuará ejecutándose normalmente.

Puedes hacer una cosa más con un bloque `try catch`, y eso es agregar un bloque `finally`. Este bloque `finally` se ejecuta independientemente de si se arrojan errores o no. Esto es ideal para fines de limpieza. Aquí hay un ejemplo simple:
```javascript
try {
    trySomething();
} catch (e) {
    console.log("Oh oh");
} finally {
    console.log("Error o no error, ¡me registraré!");
}
```

Por último, si, por alguna razón, necesitas arrojar un error, puedes hacerlo con la palabra clave `throw`, así:
```javascript
function somethingVeryDangerous() {
    throw new RangeError(); // Es una buena práctica usar 'new' para errores incorporados
}
```

Esto puede ser de gran utilidad cada vez que necesites lidiar con cosas fuera de tu control, como una respuesta API, la entrada del usuario o la entrada de la lectura de un archivo. Si suceden cosas inesperadas, a veces tendrás que lanzar un error para manejarlo apropiadamente.

## Uso de cookies
Las cookies son pequeños archivos de datos que se almacenan en tu propia computadora y son utilizados por los sitios web.

Las cookies son cadenas con un patrón especial. Contienen pares clave-valor, y estos pares clave-valor están separados por punto y coma.

Puedes crear una cookie y usarla nuevamente más tarde. Aquí se explica cómo puedes crear una cookie:
```javascript
document.cookie = "name=Maaike; favoriteColor=black";
```

En Chrome, por ejemplo, no puedes establecer las cookies desde el lado del cliente. Tienes que ejecutar el código desde un servidor.

También es posible iniciar Chrome desde la línea de comandos con ciertos ajustes habilitados, o habilitar las cookies en la configuración bajo preferencias de privacidad. Ten cuidado de desactivar esto después si no lo quieres, sin embargo. Así es como puedes leer la cookie:
```javascript
let cookie = decodeURIComponent(document.cookie);
let cookieList = cookie.split(";");
for (let i = 0; i < cookieList.length; i++) {
    let c = cookieList[i];
    if (c.charAt(0) == " ") {
        c = c.trim();
    }
    if (c.startsWith("name")) {
        alert(c.substring(5, c.length));
    }
}
```
Este ejemplo obtiene todas las cookies usando `decodeURIComponent()`, y luego las divide en el `;`. Esto nos deja con un array, `cookieList`, con pares clave-valor como cadenas. A continuación, recorremos todos los pares clave-valor. Los recortamos (eliminamos el espacio en blanco al frente y al final), y vemos si comienzan con "name". Este era el nombre de nuestra clave de cookie.

## Almacenamiento local (Local Storage)
Hemos visto las cookies como una forma de guardar datos del usuario, pero en realidad hay una forma más moderna de hacer esto: el **almacenamiento local**.

Con el almacenamiento local, podemos guardar pares clave-valor en nuestro navegador web y usarlos nuevamente en una nueva sesión (cuando el navegador se abre nuevamente más tarde).

La información normalmente se almacena en una carpeta en la computadora del usuario, pero esto difiere un poco según el navegador. Esto permite que el sitio web almacene cierta información y la recupere más tarde, incluso después de actualizar la página o cerrar el navegador.

El objeto `localStorage` es una propiedad del objeto `window`. Necesitamos poder obtener y establecer pares clave-valor en el almacenamiento local. Usamos `setItem()` cada vez que queremos guardar algo y `getItem()` cada vez que queremos recuperar el valor más tarde. Aquí se explica cómo hacerlo:
```html
<!DOCTYPE html>
<html>
<body>
    <div id="stored"></div>
    <script>
        let message = "Hello storage!";
        localStorage.setItem("example", message);

        if (localStorage.getItem("example")) {
            document.getElementById("stored").innerHTML =
            localStorage.getItem("example");
        }
    </script>
</body>
</html>
```
Aquí especificamos "example" como la clave y "Hello storage!" como el valor y lo guardamos en el almacenamiento local. Luego verificamos si la clave "example" está establecida en el almacenamiento local y mostramos los datos escribiéndolos en el `innerHTML` del `div` con el ID "stored".

También podemos recuperar una clave usando el índice. Esto es útil cada vez que necesitamos recorrer los pares clave-valor y no conocemos los nombres de las claves. Así es como se recupera una clave por índice:
```javascript
window.localStorage.key(0); // O localStorage.key(0);
```

En este caso, la clave es "name". Para obtener el valor asociado, podemos hacer esto:
```javascript
window.localStorage.getItem(window.localStorage.key(0));
```

También podemos eliminar pares clave-valor así:
```javascript
window.localStorage.removeItem("name");
```

Y podemos eliminar todos los pares clave-valor del almacenamiento local de una vez:
```javascript
window.localStorage.clear();
```

Entonces, con el almacenamiento local puedes guardar valores incluso después de cerrar el navegador.

El almacenamiento local plantea exactamente los mismos problemas que las cookies, solo que es menos conocido. Todavía tendrás que mencionar en tu sitio web que estás rastreando usuarios y almacenando información, al igual que necesitas hacerlo para las cookies.

## JSON
JSON significa JavaScript Object Notation (Notación de Objetos JavaScript), que no es más que un formato de datos. También se puede convertir fácilmente a un objeto JavaScript.

JSON es un estándar utilizado para comunicarse con las API. Las API pueden aceptar datos, por ejemplo, los datos de un formulario en un sitio web, en formato JSON.

El envío de datos desde una API ocurre, por ejemplo, cuando ingresas a una tienda web: los productos generalmente provienen de una llamada a una API que está conectada a una base de datos. Estos datos se convierten a JSON y se envían de vuelta al sitio web. Aquí hay un ejemplo de JSON:
```json
{
    "name": "Malika",
    "age": 50,
    "profession": "programmer",
    "languages": ["JavaScript", "C#", "Python"],
    "address": {
        "street": "Some street",
        "number": 123,
        "zipcode": "3850AA",
        "city": "Utrecht",
        "country": "The Netherlands"
    }
}
```

Este es un objeto que parece describir a una persona. Tiene pares clave-valor. Las claves siempre tienen que estar entre comillas, pero los valores solo tienen que estar entre comillas cuando son cadenas. Entonces, la primera clave es "name" y el primer valor es "Malika".

Las listas de valores (o arrays de JavaScript) se indican con `[]`. El objeto JSON contiene una lista de "languages", que tiene los corchetes, y otro objeto, "address". Puedes notar esto por las llaves.

En realidad, solo hay unos pocos tipos en JSON:
- Pares clave-valor con valores de los siguientes tipos: _string_, _number_, _boolean_ y _null_.
- Pares clave-valor con listas, que tienen `[` y `]` que contienen los elementos de la lista.
- Pares clave-valor con otros objetos, que tienen `{` y `}` que contienen otros elementos JSON.

### Analizando JSON (Parsing)
Una cadena de JavaScript se puede convertir a un objeto JSON usando la función `JSON.parse()`. Los datos que se reciben de otro lugar siempre son de tipo cadena, por lo que para tratarlos como un objeto, deben convertirse. Así es como se hace:
```javascript
let str = "{\"name\": \"Maaike\", \"age\": 30}"; // Nota: Se corrigió la cadena para que sea JSON válido (faltaba {})
let obj = JSON.parse(str);
console.log(obj.name, "is", obj.age);
```

A veces también es necesario lo contrario. Los objetos se pueden convertir a una cadena JSON usando el método `JSON.stringify()`. Convierte el objeto o valor de JavaScript a una cadena JSON:
```javascript
let dog = {
    "name": "wiesje",
    "breed": "dachshund"
};
let strdog = JSON.stringify(dog);
console.log(typeof strdog);
console.log(strdog);
```

```javascript
string
{"name":"wiesje","breed":"dachshund"}
```
Esto puede ser útil para almacenar datos JSON directamente en una base de datos.
