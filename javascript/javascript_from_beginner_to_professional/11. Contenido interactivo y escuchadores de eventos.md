## Introducción al contenido interactivo
El contenido interactivo es aquel que responde a las acciones de un usuario y esto es posible cambiando el DOM.
## Especificación de eventos
Hay tres formas de especificar eventos y la vimos en el anterior capítulo. Haremos un repaso:
### Especificación de eventos con HTML
```html
<p id="unique" onClick="magic()">¡Haz clic aquí para la magia!</p>
```
### Especificación de eventos con JavaScript
```javascript
document.getElementById("unique").onclick = function() { magic(); };
```
### Especificación de eventos con escuchadores de eventos (`event listeners`) 
El último método es usar el método `addEventListener()` para añadir un evento a un elemento. Con esto, podemos especificar múltiples funciones para el mismo evento.

Una característica de este método es la eliminación del prefijo `on` de los diferentes eventos.
```javascript
document.getElementById("unique").addEventListener("click", magic);
```

Si necesitas enviar parámetros en la función `magic`:
```javascript
document.getElementById("unique").addEventListener("click", function() { magic(arg1, arg2) });
```
## El manejador de eventos `onload`
El evento `onload` se activa después de que se carga un determinado elemento. 

También puedes usar `addEventListener()`. Con el elemento `DOMContentLoaded` que se ejecuta cuando todo el contenido en el DOM está cargado:
```javascript
document.addEventListener("DOMContentLoaded", (e) => { console.log(e); });
```
Esto registrará en la consola cuando todo el contenido del DOM se haya cargado.
## Manejadores de eventos del mouse (`Mouse event handeler`)
Los eventos del mouse son acciones del mouse, existen diferentes manejadores de eventos del mouse:
- `ondblclick`: cuando se hace doble clic con el mouse.
- `onmousedown`: cuando el mouse hace clic sobre un elemento sin que se suelte el clic.
- `onmouseup`: cuando se suelta el clic del mouse sobre un elemento.
- `onmouseenter`: cuando el mouse se mueve sobre un elemento.
- `onmouseleave`: cuando el mouse sale de un elemento y todos sus hijos.
- `onmousemove`: cuando el mouse se mueve sobre un elemento.
- `onmouseout`: cuando el mouse sale de un elemento individual.
- `onmouseover`: cuando el mouse se desplaza sobre un elemento (_hover_).

```html
<!doctype html>
<html>
<body>
<div id="divvy" onmouseover="changeColor()" style="width: 100px; height: 100px; background-color: pink;">
<script>
    function changeColor() {
        document.getElementById("divvy").style.backgroundColor = "blue";
    }
</script>
</body>
</html>
```
Si pasas el mouse sobre el cuadrado rosa, se vuelve azul inmediatamente.
## La propiedad `target` del evento
Siempre que se activa un evento, una variable de evento está disponible. Tiene muchas propiedades, y puedes verificarlo usando este comando en la función que se activa para el evento:
```javascript
console.dir(event);
```
Esto mostrará muchas propiedades, pero una de esas propiedades es `target`.

`target` es el elemento HTML que activó el evento. Entonces, podemos usarlo para obtener información de una página web:
```html
<!doctype html>
<html>
<body>
    <button type="button" onclick="triggerSomething()">Click</button>
    <script>
    function triggerSomething() {
        console.dir(event.target);
    }
    </script>
</body>
</html>
```
En este caso, `event.target` es el elemento `button`. En la consola, se registrará el elemento `button` y todas sus propiedades, incluyendo potenciales hermanos (`siblings`) y padres (`parents`).

Un caso de uso es en los formularios HTML. Un botón en un formulario a menudo tendría el formulario como su padre directo. A través de este padre, se pueden obtener datos de los campos de entrada:
```html
<!doctype html>
<html>
<body>
    <div id="welcome">¡Hola!</div>
    <form>
        <input type="text" name="firstname" placeholder="Nombre" />
        <input type="text" name="lastname" placeholder="Apellido" />
        <input type="button" onclick="sendInfo()" value="Enviar" />
    </form>
    <script>
    function sendInfo() {
        let p = event.target.parentElement;
        message("Bienvenido " + p.firstname.value + " " + p.lastname.value);
    }
    function message(m) {
        document.getElementById("welcome").innerHTML = m;
    }
    </script>
</body>
</html>
```
## Flujo de eventos del DOM (`DOM event flow`)
```html
<!DOCTYPE html>
<html>
<body>
<style>
div {
    border: 1px solid black;
    margin-left: 5px;
}
</style>
<div id="message">Eventos de Burbuja</div>
<div id="output">
    1
    <div>
        2
        <div>
            3
            <div>
                4
                <div>5</div>
            </div>
        </div>
    </div>
</div>
<script>
    function bubble() {
        console.log(this.innerText);
    }
    let divs = document.getElementsByTagName("div");
    for (let i = 0; i < divs.length; i++) {
        divs[i].addEventListener("click", bubble);
    }
</script>
</body>
</html>
```
Ejecutará los cinco eventos, por lo que cada uno de cada `div` anidado. Y los ejecutará de adentro hacia afuera:
```text
5
45
345
2345
12345
```

Esto se llama burbujeo de eventos (event bubbling). Es lo que sucede cuando activas los manejadores en un elemento. Ejecuta sus propios eventos primero, luego los de sus padres, y así sucesivamente. Se llama burbujeo porque sube desde el evento interno al externo, como las burbujas de agua que suben.

Puedes alterar este comportamiento agregando `true` como tercer argumento cuando agregas el escuchador de eventos, así:
```javascript
divs[i].addEventListener("click", bubble, true);
```

Este sería el resultado:
```text
12345
2345
345
45
5
```
Este movimiento desde el elemento exterior hacia el elemento interior se llama **captura de eventos (event capturing)**.

La captura y el burbujeo de eventos nos permiten aplicar un principio llamado **delegación de eventos (event delegation)**. La delegación de eventos es el concepto donde, en lugar de agregar manejadores de eventos a cada elemento en un cierto bloque de HTML, definimos un contenedor y agregamos el evento a este elemento contenedor, y luego se aplica a todos los elementos secundarios también.
## `onchange` y `onblur`
`onchange` se activa cuando un elemento cambia, por ejemplo, cuando cambia el valor de un cuadro de entrada. `onblur` se activa cuando un objeto pierde el foco; por ejemplo, cuando tienes el cursor en un cuadro de entrada y el cursor pasa a otro cuadro de entrada, se activará el evento `onblur` del primer cuadro de entrada.

```html
<!DOCTYPE html>
<html>
<body>
<div id="welcome">¡Hola!</div>
<form>
    <input type="text" name="firstname" placeholder="Nombre" onchange="logEvent()" />
    <input type="text" name="lastname" placeholder="Apellido" onblur="logEvent()" />
    <input type="button" onclick="sendInfo()" value="Enviar" />
</form>
<script>
    function logEvent() {
        let p = event.target;
        if (p.name == "firstname") {
            message("Nombre cambiado a " + p.value);
        } else {
            message("Apellido cambiado a " + p.value);
        }
    }

    function sendInfo() {
        let p = event.target.parentElement;
        message("Bienvenido " + p.firstname.value + " " + p.lastname.value);
    }

    function message(m) {
        document.getElementById("welcome").innerHTML = m;
    }
</script>
</body>
</html>
```
El cuadro de entrada `firstname` tiene un evento `onchange`. Si el valor de los datos en el cuadro de entrada cambia, este evento se activa tan pronto como el cuadro de entrada pierde el foco. Si el cuadro de entrada pierde el foco cuando el valor no ha cambiado, no sucede nada para `onchange`. Esto no es cierto para `onblur`, que está asignado al cuadro de entrada `lastname`. Incluso cuando el valor no ha cambiado, el evento se activará.

Otro evento que se usa a menudo con cuadros de entrada es `onfocus`, o simplemente `focus` cuando se usa en combinación con un escuchador de eventos. Este evento está asociado con el cursor que ingresa al cuadro de entrada, y se activa cuando el cuadro de entrada recibe el foco del cursor y se puede ingresar información.
## Manejador de eventos del teclado (`key event handler`)
`onkeypress` se activa, bueno, puedes haberlo adivinado, cada vez que se presiona una tecla. Si quieres que un evento ocurra tan pronto como se presione el botón (antes de soltarlo), puedes usar el evento `onkeydown`. Si quieres que el evento ocurra al soltar, puedes usar el evento `onkeyup`.

Podemos obtener la tecla que activó el evento usando:
```javascript
event.key;
```

El siguiente código HTML tiene dos cuadros de entrada:
```html
<!doctype html>
<html>
<body>
<div id="wrapper">¡JavaScript es divertido!</div>
<input type="text" name="myNum1" onkeypress="numCheck()">
<input type="text" name="myNum2" onkeypress="numCheck2()">
<script>
    function numCheck() {
        message("Número: " + !isNaN(event.key));
        return !isNaN(event.key);
    }

    function numCheck2() {
        message("No es un número: " + isNaN(event.key));
        return isNaN(event.key);
    }

    function message(m) {
        document.getElementById('wrapper').innerHTML = m;
    }
</script>
</body>
</html>
```
El primero verifica si un valor es un número, y si es un número, escribirá "Número: true" en la parte superior; de lo contrario, escribirá "Número: false" en la parte superior. El segundo está verificando si un valor no es un número; si no es un número, escribirá "No es un número: true"; de lo contrario, escribirá "No es un número: false".

Podemos agregar una declaración `return` a nuestro evento `onkeypress`:
```html
onkeypress="return numCheck2()";
```
Si se devuelve `true`, el valor de la tecla se agrega al cuadro de entrada; si se devuelve `false`, el valor de la tecla no se agrega.
## Elementos de arrastrar y soltar (`Drag and drop`)
También hay manejadores de eventos especiales para arrastrar y soltar. Necesitamos un punto de partida para poder arrastrar y soltar algo.

Creemos el CSS y HTML para un área de arrastrar y soltar:
```html
<!doctype>
<html>
<head>
    <style>
    .box {
        height: 200px;
        width: 200px;
        padding: 20px;
        margin: 0 50px;
        display: inline-block;
        border: 1px solid black;
    }
    #dragme {
        background-color: red;
    }
    </style>
</head>
<body>
    <div class="box" ondrop="dDrop()" ondragover="nDrop()">
    1
	    <div id="dragme" ondragstart="dStart()" draggable="true">
	        ¡Arrástrame por favor!
	    </div>
	</div>
	<div class="box" ondrop="dDrop()" ondragover="nDrop()">2</div>
    <script>
        let holderItem;

        function dStart() {
            holderItem = event.target;
        }

        function nDrop() {
            event.preventDefault();
        }

        function dDrop() {
            event.preventDefault();
            if (event.target.className == "box") {
                event.target.appendChild(holderItem);
            }
        }
    </script>
</body>
</html>
```
Necesitamos incluir un elemento que va a ser arrastrado y soltado. Para marcar un elemento como algo que se puede arrastrar, necesitamos agregar el atributo `draggable`.

Luego necesitamos decidir qué vamos a hacer cuando soltemos el elemento arrastrable. Necesitamos especificar esto dentro de la caja a la que se puede arrastrar. Vamos a agregar la funcionalidad a ambas cajas, para que pueda ser arrastrado a una y de vuelta a la otra.
## Envío de formularios (`Form submission` )
Cuando se envía un formulario, se puede activar un evento. Esto se puede lograr de diferentes maneras, y una de ellas es agregar al elemento `form` el atributo `onsubmit`.
```html
<form onsubmit="doSomething()">
```
La función que se enumera allí se activará cada vez que se envíe un `input` de tipo `submit`.

```html
<input type="submit" value="send">
```

Podemos hacer más con el HTML del elemento `form`; por ejemplo, podemos redirigir a otra página. Tenemos que especificar la forma en que queremos enviar los valores del formulario usando el atributo `method` y la página de ubicación usando el atributo `action`.
```html
<form action="anotherpage.html" method="get" onsubmit="doStuff()">
```

No te preocupes por el `get` por ahora; esto solo significa que los valores se envían a través de la URL. Las URL se ven así cuando usas `get`:
```text
www.example.com/anotherpage.html?name=edward
```

Después del signo de interrogación, se muestran las variables que se envían junto con en pares clave-valor. Este es el formulario que creó la URL cuando se insertó `edward` para `name`.
```html
<!doctype html>
<html>
<body>
    <form action="anotherpage.html" method="get">
        <input type="text" placeholder="name" name="name" />
        <input type="submit" value="send" />
    </form>
</body>
</html>
```

Es muy útil si queremos hacer alguna validación de formulario antes de enviarlo:
```html
<!doctype html>
<html>
<body>
    <div id="wrapper"></div>
    <form action="anotherpage.html" method="get" onsubmit="return valForm()">
        <input type="text" id="firstName" name="firstName" placeholder="Nombre" />
        <input type="text" id="lastName" name="lastName" placeholder="Apellido" />
        <input type="text" id="age" name="age" placeholder="Edad" />
        <input type="submit" value="submit" />
    </form>
    <script>
    function valForm() {
        var p = event.target.children;
        if (p.firstName.value == "") {
            message("¡Se necesita un nombre!");
            return false;
        }
        if (p.lastName.value == "") {
            message("¡Se necesita un apellido!");
            return false;
        }
        if (p.age.value == "") {
            message("¡Se necesita una edad!");
            return false;
        }
        return true;
    }

    function message(m) {
        document.getElementById("wrapper").innerHTML = m;
    }
    </script>
</body>
</html>
```
Este formulario contiene tres campos de entrada y un botón de envío. Los campos son para apellido, nombre y edad. Cuando falta uno de ellos, el formulario no se enviará, porque la función devolverá `false`. También se agregará un mensaje al `div` above del formulario, explicando qué salió mal.
## Animación de elementos (`Animating elements`)
Podemos animar usando HTML, CSS y JavaScript. Por ejemplo, podemos activar una animación como un evento. Se puede usar para muchos propósitos diferentes, por ejemplo, para ilustrar una explicación, para dirigir la mirada del usuario a una determinada ubicación o para jugar un juego.

Podemos usar la clave `position` y establecerla en `absolute` en CSS. Esto hace que la posición del elemento sea relativa a su elemento padre posicionado más cercano. Aquí, ese sería el `body`. Este es el código para un cuadrado púrpura que se mueve de izquierda a derecha cuando se hace clic en un botón:
```html
<!doctype html>
<html>
    <style>
    div {
        background-color: purple;
        width: 100px;
        height: 100px;
        position: absolute;
    }
    </style>
<body>
    <button onclick="toTheRight()">Ir a la derecha</button>
    <div id="block"></div>
    <script>
    function toTheRight() {
        let b = document.getElementById("block");
        let x = 0;
        setInterval(function () {
            if (x == 600) {
                clearInterval();
            } else {
                x++;
                b.style.left = x + "px";
            }
        }, 2);
    }
    </script>
</body>
</html>
```
Necesitamos dar al `div` block una posición `absolute`, porque confiamos en la propiedad CSS `left` para hacerlo mover. Para estar a la izquierda de algo, ese algo necesita ser `absolute`, de lo contrario, la propiedad `left` no se puede posicionar en relación con él. En este caso, necesitamos estar a un cierto número de píxeles a la izquierda del `div`; esta es la razón por la que necesitamos que la posición del `div` sea `absolute`, para que la posición del cuadro en movimiento pueda ser relativa a la de su padre.

Cuando hacemos clic en el botón, se activa la función `toTheRight()`. Esta función toma `block` y lo almacena en `b`. Establece `x` en 0. Luego usamos una función JavaScript integrada muy poderosa: `setInterval()`. Esta función sigue evaluando una expresión hasta que se llama a `clearInterval()`. Esto se hace cuando `x`, la medida de qué tan lejos estamos a la izquierda, alcanza 600. Lo repite cada 2 milisegundos, lo que le da el aspecto deslizante.

Puedes al mismo tiempo también establecer diferentes posiciones, como `style.top`, `style.bottom` y `style.right`, o agregar nuevos elementos para crear un efecto de nieve, o mostrar coches conduciendo constantemente. Con esto en tu caja de herramientas, el cielo es el límite.

