Una promesa en JavaScript es un objeto que representa la terminación (o el fracaso) eventual de una operación asíncrona y su valor resultante.

**Analogía del Mundo Real:** Imagina que pides una hamburguesa en un restaurante lleno:
1. Pagas y te dan un **Ticket** (La Promesa). El ticket no es la hamburguesa, es una garantía futura.
2. **Estado Pendiente:** Mientras esperas, el ticket está en estado `pending`.
3. **Resolución (Éxito):** Te llaman y te dan la comida. El ticket se cambia por la hamburguesa (`resolve`).
4. **Rechazo (Fallo):** Te avisan que se acabó la carne. La operación falló (`reject`).

**Los 3 Estados de una Promesa:**
Una promesa siempre se encuentra en uno de estos estados:
- **Pending (Pendiente):** Estado inicial, no se ha cumplido ni rechazado.
- **Fulfilled (Cumplida):** La operación se completó con éxito. Se ejecuta la función `resolve`.
- **Rejected (Rechazada):** La operación falló. Se ejecuta la función `reject`.
## Creando una promesa
Se usa el constructor `new Promise()`, el cual recibe una función ejecutora con dos parámetros: `resolve` y `reject`:
```javascript
const miPromesa = new Promise((resolve, reject) => {
  const tareaExitosa = true; // Simulación: cambiar a false para probar el error

  // Simulamos una demora de 2 segundos (como pedir datos a internet)
  setTimeout(() => {
    if (tareaExitosa) {
      // Si todo sale bien, llamamos a resolve con los datos
      resolve("¡Operación completada con éxito!"); 
    } else {
      // Si algo falla, llamamos a reject con el error
      reject("Hubo un error en el sistema.");
    }
  }, 2000);
});
```
## Consumiendo la promesa (`.then` y `.catch`)
Una vez que se tiene el objeto promesa (`miPromesa`), se usan métodos para reaccionar cuando deje de estar "pendiente".
- `.then()`: Se ejecuta si la promesa se **resuelve**. Recibe lo que se pasó en `resolve()`.
- `.catch()`: Se ejecuta si la promesa es **rechazada**. Recibe lo que se pasó en `reject()`. 
- `.finally()`: Se ejecuta siempre al final, sin importar si hubo éxito o error (útil para ocultar spinners de carga).
```javascript
console.log("1. Iniciando proceso...");

miPromesa
  .then((mensaje) => {
    // Entra aquí solo si tareaExitosa = true
    console.log("2. Éxito:", mensaje);
  })
  .catch((error) => {
    // Entra aquí solo si tareaExitosa = false
    console.error("2. Error:", error);
  })
  .finally(() => {
    // Se ejecuta siempre
    console.log("3. Proceso terminado (Limpieza)");
  });

console.log("4. El código sigue sin esperar...");
```
## El encadenamiento
- La gran mejora respecto a los callbacks es que las promesas se pueden encadenar. 
- Si dentro de un `.then()` retornas otra promesa, puedes poner otro `.then()` abajo. 
- El código se lee verticalmente en lugar de anidarse hacia la derecha.
```javascript
// Ejemplo conceptual de encadenamiento
conectarBaseDeDatos()
  .then(conexion => loguearUsuario(conexion))
  .then(usuario => obtenerPermisos(usuario))
  .then(permisos => mostrarPanel(permisos))
  .catch(error => console.log("Falló alguno de los pasos anteriores:", error));
```
