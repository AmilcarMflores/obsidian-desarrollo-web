`fetch` es una función nativa de JavaScript que permite realizar peticiones HTTP asíncronas:
- **Basado en promesas:** Por eso funciona perfecto con `async/await`.
- **Reemplazo de AJAX:** Sustituye al antiguo y verboso objeto `XMLHttpRequest`.

Un error común al empezar con `fetch` es pensar que recibes los datos inmediatamente. En realidad, el proceso tiene dos etapas:
1. **Petición de conexión (`fetch`):** El navegador contacta al servidor y recibe los "encabezados" (status 200, tipo de contenido, etc.). Aquí **aún no tienes los daots (JSON)**, tienes un objeto `Response` que es un flujo de datos (stream) abierto.
2. **Extracción de datos (`.json()`):** Debes decirle explícitamente a ese flujo que lea el cuerpo del mensaje y lo convierta a JSON. Esto también es asíncrono y devuelve una segunda promesa.

**Ejemplo 1: Petición GET (Lectura)**
Vamos a consumir una API real y gratuita (JSONPlaceholder) para traer una lista de usuarios.
```javascript
const url = "https://jsonplaceholder.typicode.com/users";

async function obtenerUsuarios() {
  try {
    console.log("1. Llamando a la API...");
    
    // PASO 1: La petición HTTP
    // 'res' es el objeto Response (información de la conexión, no el JSON final)
    const res = await fetch(url);

    // Verificamos qué tenemos en 'res'
    console.log("Status:", res.status); // 200 (OK) o 404 (Not Found)
    console.log("OK?", res.ok);         // true si el status es 200-299

    // PASO 2: Convertir el Stream a JSON
    // El método .json() también es asíncrono, por eso requiere 'await'
    const datos = await res.json();

    console.log("3. Datos convertidos:", datos);
    
    // Aquí ya podríamos pintar el HTML...
    // datos.forEach(user => ...)

  } catch (error) {
    console.error("Hubo un error de red:", error);
  }
}

obtenerUsuarios();
```
**El Manejo de Errores (404/500)**:
A diferencia de otras librerías (como jQuery o Axios), **`fetch` NO rechaza la promesa si el servidor responde con un error 404 (No encontrado) o 500 (Error de servidor)**:

- Para `fetch`, si el servidor responde "Hola, no encontré tu archivo", eso cuenta como una conexión exitosa (la promesa se resuelve).
- Solo rechaza la promesa (va al `catch`) si hay un **fallo de red** (sin internet, DNS caído).

**La Solución Profesional:** Debemos verificar manualmente la propiedad `res.ok` y lanzar el error nosotros mismos.
```javascript
const res = await fetch("https://api.falsa/usuarios");

// Si la respuesta NO es exitosa (ej: 404), forzamos el error
if (!res.ok) {
  // throw enviará el flujo directamente al bloque catch
  throw new Error(`Error HTTP: ${res.status} - ${res.statusText}`);
}

const data = await res.json();
```
**Ejemplo 2: Petición POST (Envío de Datos)**
Por defecto, `fetch` hace peticiones **GET**. Para crear datos (POST), actualizar (PUT) o borrar (DELETE), necesitamos pasar un segundo argumento: el objeto de configuración.
```javascript
async function crearUsuario() {
  const nuevoUsuario = {
    name: "Mentor JS",
    job: "Developer"
  };

  try {
    const res = await fetch("https://reqres.in/api/users", {
      method: "POST", // 1. Verbo HTTP
      headers: {
        // 2. Avisamos al servidor que enviamos JSON
        "Content-Type": "application/json" 
      },
      // 3. Convertimos nuestro objeto JS a texto JSON para viajar por la red
      body: JSON.stringify(nuevoUsuario) 
    });

    if (!res.ok) throw new Error("No se pudo crear el usuario");

    const respuestaServidor = await res.json();
    console.log("Usuario creado con éxito:", respuestaServidor);

  } catch (error) {
    console.error(error);
  }
}

crearUsuario();
```
## Notas
1. **`JSON.stringify()` vs `.json()`**:
    - `JSON.stringify(objeto)`: Convierte objeto JS -> Texto JSON (para **enviar** al servidor).
    - `respuesta.json()`: Convierte Texto JSON (del servidor) -> Objeto JS (para **usar** en tu código)

2. **CORS (Cross-Origin Resource Sharing)**: Si intentas hacer fetch a una API que no está configurada para recibir peticiones desde tu dominio, verás un error de CORS. Es una medida de seguridad del navegador, no un error de tu código `fetch`.