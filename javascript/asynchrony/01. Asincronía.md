- JavaScript es un lenguaje **Single Threaded** (de un solo hilo).
- Imagina que JS es una persona con **una sola mano**. Solo puede hacer **una cosa a la vez**.
## Programación síncrona (bloqueante)
- Es el código que se lee de arriba hacia abajo.
- La línea 2 no se ejecuta hasta que la línea 1 termina por completo.
## Programación asíncrona (no bloqueante)
JavaScript, aunque tenga una sola mano, **delega tareas pesadas y sigue trabajando**.

**Analogía del Restaurante Asíncrono (JS Real):** Hay un solo mesero (JavaScript):
1. El Cliente A pide una pizza.
2. El mesero pasa la nota a la cocina (Navegador/API) y le dice: "Avísame cuando esté lista".
3. **Inmediatamente** va a atender al Cliente B.
4. Cuando la cocina termina la pizza, toca un timbre (Callback) y el mesero la entrega cuando tiene un segundo libre.

**Por ejemplo:**
¿En qué orden crees que aparecerán los números en la consola?
```javascript
console.log("1. Inicio del programa");

// Esto es una tarea Asíncrona (simulamos que tarda 2 segundos)
setTimeout(function() {
    console.log("2. Tarea pesada completada");
}, 2000);

console.log("3. Fin del programa");
```
**La Respuesta:**
1. `"1. Inicio del programa"`
2. `"3. Fin del programa"`
3. (Pasan 2 segundos...)
4. `"2. Tarea pesada completada"`

JavaScript leyó la línea 1. Luego leyó la línea del `setTimeout` y dijo: _"Ok, esto demora. Navegador, cuenta 2 segundos y avísame. Yo no me voy a quedar esperando"_. Y saltó inmediatamente a la línea del "3. Fin".
## El event loop (el ciclo de eventos)
Para que esto funcione, JavaScript usa una estructura muy inteligente:
1. **Call Stack (Pila de Ejecución)**: Es donde JS está trabajando ahora mismo. 
2. **Web APIs**: Es el "cuarto de atrás" donde el navegador maneja los temporizadores (`setTimeout`), peticiones de red, etc.
3. **Callback Queue (Cola de Tareas):** Es una sala de espera. Cuando el temporizador de 2 segundos termina, la función `function() { console.log("2...") }` se mueve aquí y espera su turno.
4. **Event Loop (El portero)**: Es un vigilante que mira la pila y la cola. Su regla es: "Solo dejaré pasar a alguien de la cola a la pila si la pila está totalmente vacía".
Por eso, aunque pongas `setTimeout(..., 0)`, el código asíncrono **siempre** se ejecutará después de todo el código síncrono principal.
